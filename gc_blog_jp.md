# WebAssemblyで自作言語用のGCを書く

[前回](http://a-kawashiro.hatenablog.com/entry/2018/10/31/211424)の続きです。

前回の記事で書いたようにWebAssemblyにはGabage Collection (GC) が未だに実装されていないため(2019/7/8時点)、メモリ管理は全て自分で行う必要があります。今回はWebAssemblyを出力する自作言語のためのGC(malloc, freeを含む)をwasmで作りました。

WebAssemblyはスタックマシンで実行される言語であり、各命令は引数をスタックのトップから取り出し結果をスタックのトップに積みます。トップ以外のスタックの中身を自由に見ることはできません(注1)。また、スタックの他にも[リニアメモリ](https://webassembly.org/docs/semantics/#linear-memory)も持ち、`i32.store`, `i32.load`といった命令でアクセスすることができます。リニアメモリは以下のような特徴を持ちます。
- アドレスは0から始まる
- アドレスは32bit
- 整数又は浮動小数点数をstore/loadできる

注1: 現在のスタックの長さを記録しておけばリニアメモリにスタックの中身をすべて書き出すことはできる。ただしstore/load命令が整数と浮動小数点数で異なるので、スタックに積まれている全ての値について整数なのか浮動小数点数なのかという情報も保存しておく必要がある。

GCを書く前にまずmallocとfreeが必要です。今回はfree listでブロックを管理する簡単なものを書きました。各ブロックは図1のような構造になっていて、次のブロックのアドレス、ブロックサイズ、フラグ、確保したメモリを保持します。フラグにはfree listの終端かどうかの情報とブロックが使用中かどうかの情報が入っています。それぞれ4byteずつ使うのでmallocのためのヘッダだけで12byteも使います。贅沢ですね。

mallocはfree listを先頭から走査して要求されたサイズ以上の空きブロックがあれば確保、最後まで走査して該当するブロックがなければ末尾に新たにブロックを作ります。freeは指定されたブロックの状態を空きブロックに変えるだけです。空きブロック同士を結合する処理はめんどくさいのでやっていません。

このmallocとfreeを使ってGCを作ります。[『ガベージコレクション』](https://www.amazon.co.jp/dp/B01CYDGUT0/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1)によれば、GCには次の3種類があります。
- マーク・アンド・スイープ
- コピーGC
- 参照カウント
このうち、マーク・アンド・スイープとコピーGCは生きているオブジェクトを探索するのにルートセットが必要です。ルートセットは一般にレジスタ、スタック、グローバル変数から構成されます。ところが、WebAssemblyではスタックの中身を自由に見ることができないためルートセットが必要なGCは採用できません(注2)。このため今回は参照カウント方式でGCを実装しました。 

注2: 注1のようにスタックの中身をリニアメモリに書き出せれば、ルートセットが必要な方式も採用できる。

まず、コンパイラが変数のスコープに応じてオブジェクトの参照カウントを増減させるコードを挿入します。
